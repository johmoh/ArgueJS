<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>arguejs2.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/ANYTYPE.html">ANYTYPE</a></li>
            
                <li><a href="../classes/ArgueJS.html">ArgueJS</a></li>
            
                <li><a href="../classes/module-arguejs.html">module-arguejs</a></li>
            
                <li><a href="../classes/TAIL.html">TAIL</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/module-arguejs.html">module-arguejs</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: arguejs2.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
// [[&gt;&gt;&gt; make module available in node.js and the web (AMD - RequireJS)]]
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
if (typeof define !== &#x27;function&#x27;) {
    var define = require(&#x27;amdefine&#x27;)(module);
}

define(function(require) {

    &quot;use strict&quot;;

    // initialize and return module
    return function(module_exports_factory){
        return module_exports_factory(
            /* put some static configuration values here */
        );
    }(

    function(
        /* define variables for some static configuration values here */
    ) {
// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// [[&lt;&lt;&lt; make module available in node.js and the web (AMD - RequireJS)]]
// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

    /**
     * Module ArgueJS
     *
     * @module  module-arguejs
     */

    /* ###############################################################################################
     *
     * Some configuration values for this module.
     *
     * These configuration values are private to this module.
     *
     * ###############################################################################################
     */

    /** const */ var DEFAULT_OPTION_VALUE_ALLOWNULL                     = false;
    /** const */ var DEFAULT_OPTION_VALUE_ALLOWUNDEFINED                = false;
    /** const */ var DEFAULT_OPTION_VALUE_PARAMETERPARENTHESIZETAIL     = true;

    /* ###############################################################################################
     *
     * Error texts
     *
     * These texts are private to this module.
     *
     * ###############################################################################################
     */

    /** const */ var $ERR_BADCALL_PREFIX                                        = &quot;bad call: &quot;;
    /** const */ var $ERR_BADCALL_InvalidTypeOfArgument                         = $ERR_BADCALL_PREFIX + &quot;type of \&quot;{1}\&quot; is invalid.&quot;;
    /** const */ var $ERR_BADCALL_NoArguments                                   = $ERR_BADCALL_PREFIX + &quot;no arguments. function call is not compatible with function specification.&quot;;
    /** const */ var $ERR_BADCALL_TooManyArguments                              = $ERR_BADCALL_PREFIX + &quot;too many arguments. function call is not compatible with function specification.&quot;;
    /** const */ var $ERR_BADCALL_InvalidTypeOfParameter                        = $ERR_BADCALL_PREFIX + &quot;parameter specification #{1} is not an object structure.&quot;;

    /** const */ var $ERR_ARGUEJS_PREFIX                                        = &quot;parameter specification \&quot;{1}\&quot;: &quot;;
    /** const */ var $ERR_ARGUEJS_DefaultValueHasIncompatibleType               = $ERR_ARGUEJS_PREFIX + &quot;default value is not compatible to parameter type&quot;;
    /** const */ var $ERR_ARGUEJS_InvalidTypeOfValue                            = $ERR_ARGUEJS_PREFIX + &quot;value of \&quot;{2}\&quot; has incorrect type (must be {3})&quot;;
    /** const */ var $ERR_ARGUEJS_InvalidTypeSpecificationOption                = $ERR_ARGUEJS_PREFIX + &quot;option \&quot;{2}\&quot; in type specification is invalid.&quot;;
    /** const */ var $ERR_ARGUEJS_InvalidValue                                  = $ERR_ARGUEJS_PREFIX + &quot;\&quot;{2}\&quot; is invalid.&quot;;
    /** const */ var $ERR_ARGUEJS_MissingTypeSpecification                      = $ERR_ARGUEJS_PREFIX + &quot;type specification is missing.&quot;;
    /** const */ var $ERR_ARGUEJS_ParameterWithoutSpecification                 = &quot;parameter specification #{1} is missing.&quot;;
    /** const */ var $ERR_ARGUEJS_ParameterWithTooManyElements                  = $ERR_ARGUEJS_PREFIX + &quot;specification contains more than one element.&quot;;
    /** const */ var $ERR_ARGUEJS_ParameterXYZAllowedInVariadicFunction         = $ERR_ARGUEJS_PREFIX + &quot;\&quot;{2}\&quot; is {3} allowed for the tail-parameter in a variadic function&quot;;
    /** const */ var $ERR_ARGUEJS_TailParameterMustBeLastPastparameter          = &quot;in a variadic function the tail-parameter must be the last parameter in the function specification.&quot;;
    /** const */ var $ERR_ARGUEJS_TypeSpecificationHasTooManyElements           = $ERR_ARGUEJS_PREFIX + &quot;type specification has too many elements.&quot;;

    /** const */ var $ERR_ARGUEJS_GetParameters_PREFIX                          = &quot;Incompatible function call: &quot;;
    /** const */ var $ERR_ARGUEJS_GetParameters_MandatoryParameterWithoutValue  = $ERR_ARGUEJS_GetParameters_PREFIX + &quot;mandatory argument \&quot;{1}\&quot; has no value.&quot;;
    /** const */ var $ERR_ARGUEJS_GetParameters_TooManyArguments                = $ERR_ARGUEJS_GetParameters_PREFIX + &quot;too many arguments. {1}&quot;;

    /* ###############################################################################################
     *
     * Utility functions for handling types
     *
     * These functions are private to the module.
     *
     * ###############################################################################################
     */

    /**
     * Tests, if a value is a Boolean.
     *
     * @for       module-arguejs
     * @function  isBoolean
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is a Boolean. False, otherwise.
     */
    function isBoolean(_value) {
        return (typeof(_value) === &#x27;boolean&#x27;);
    }

    /**
     * Tests, if a value is a Array.
     *
     * @for       module-arguejs
     * @function  isArray
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is a Array. False, otherwise.
     */
    function isArray(_value) {
        return (_value instanceof Array);
    }

    /**
     * Tests, if a value is a Function.
     *
     * @for       module-arguejs
     * @function  isFunction
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is a Function. False, otherwise.
     */
    function isFunction(_value) {
        return (typeof(_value) === &#x27;function&#x27;);
    }

    /**
     * Tests, if a value is a Object.
     *
     * @for       module-arguejs
     * @function  isObject
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is a Object. False, otherwise.
     */
    function isObject(_value) {
        return (_value instanceof Object);
    }

    /**
     * Tests, if a value is an Arguments-object.
     *
     * @for       module-arguejs
     * @function  isArguments
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is an Arguments object. False, otherwise.
     */
    var isArguments = function() {
        var argumentsDetectionText = Object.prototype.toString.call(arguments);
        return function(_value) {
            return _value &amp;&amp; Object.prototype.toString.call(_value) === argumentsDetectionText;
        };
    }();

    /**
     * Tests, if a value is a &quot;Type&quot;. This function summarizes logic for detecting, if a value is a type. In JavaScript does not exist anything like a &quot;Type&quot;-type.
     * So, some logic is needed to distinguish between a value/object/function and a type.
     *
     * @for       module-arguejs
     * @function  isType
     *
     * @param  {*}  _value  The value to test.
     *
     * @return {Boolean}  True, if the value is a &quot;Type&quot;. False, otherwise.
     */
    function isType(_value) {
        return isFunction(_value); // @TODO: maybe that can be improved.
    }

    /**
     * Returns the type of a value.
     *
     * @for       module-arguejs
     * @function  getType
     *
     * @param  {*}  _value  A value.
     *
     * @return {Type}  The type of _value. It is not a string representation. It is the type. For &quot;text&quot; it returns String, and so on...
     *
     * @example
     * 
     * var a = 17;
     * var b = getType(a);
     * var c = b(20);
     *
     * console.log(a); // OUTPUT: 17
     * console.log(b); // OUTPUT: [Function: Number]
     * console.log(c); // OUTPUT: 20
     */
    var getType = function(_value) {
        if (_value === undefined) { return undefined; }
        if (_value === null)      { return null; }
        return _value.constructor;
    };

    /* ###############################################################################################
     *
     * Utility functions for generating error messages
     *
     * These functions are private to the module.
     *
     * ###############################################################################################
     */

    /**
     * Formats a string and returns the result.
     *
     * This is a variadic function. Placeholders are delivered as normal arguments after the _formatString argument. In the _formatString occurrences of &quot;{X}&quot; - where &quot;X&quot; is
     * a number beginning with 1 - are replaced by the argument at position &quot;X&quot;.
     *
     * @for       module-arguejs
     * @function  formatText
     *
     * @param {string}  _formatString  Format string containing placeholders.
     * @param {[...*]}  [...]          Optional: Arguments: Arguments to use in this variadic function. These arguments are used to fill in placeholder in the format string.
     *
     * @return {string}  Resulting, formatted text.
     *
     * @example
     *
     * var text = Utilities.formatString(&quot;{1}{3}, {2} {1}&quot;, &quot;!!!&quot;, &quot;folks&quot;, &quot; hi&quot;);  // text = &quot;!!! hi, folks !!!&quot;
     */
    function formatText(_formatString, _arguments) {
        var result = _formatString;
        if (result) {
                var argumentsLength = arguments.length;
            for (var idx = 1; idx &lt; argumentsLength; ++idx) {
                var replacement = arguments[idx];
                result = result.replace(new RegExp(&quot;\\{&quot;+idx+&quot;\\}&quot;, &quot;g&quot;), replacement);
            }
        }
        return result;
    }

    /* ###############################################################################################
     *
     * Utility functions for validating data
     *
     * These functions are private to the module.
     *
     * ###############################################################################################
     */

    /**
     * Validates a parameter name.
     *
     * @for       module-arguejs
     * @function  validateParameterName
     *
     * @param {String}  _parameterName  Name of a parameter.
     *
     * @return {Boolean}  True, if the 
     */
    var validateParameterName = function() {
        var regExp = /^[_a-z$]{1}[_a-z0-9$]*$/i;
        return function(_parameterName) {
            return _parameterName &amp;&amp; regExp.test(_parameterName);
        };
    }();

    /**
     * Tests, if a value is compatible to a type and some options and if the value can be used as a default value or as a normal argument value.
     *
     * @for       module-arguejs
     * @function  isCompatibleValue
     *
     * @param  {*}        _value           A value.
     * @param  {Type}     _type            A type the value should be compatible with.
     * @param  {Boolean}  _allowUndefined  True, if an undefined value can be treated compatible. False, otherwise.
     * @param  {Boolean}  _allowNull       True, if a null value can be treated compatible. False, otherwise.
     * @param  {Boolean}  _asDefaultValue  True, if the test is for testing a default value. False, otherwise. The reason for this parameter is simple: A value of any type 
     *                                     can be part of the tail-parameter of a variadic function. But that parameter is an array. So only an array can be a default parameter.
     *
     * @return {Boolean}  True, if a value is compatible to a type and some options. False, otherwise.
     */
    function isCompatibleValue(_value, _type, _allowUndefined, _allowNull, _asDefaultValue) {
        if (_asDefaultValue) {

            if (_value === undefined)    { return (_allowUndefined === true); } // value &quot;undefined&quot; is compatible if &quot;undefined&quot; is allowed
            if (_value === null)         { return (_allowNull === true); } // value &quot;null&quot; is compatible if &quot;null&quot; is allowed
            if (_type  === ArgueJS.TAIL) { return isArray(_value); } // only an array is compatible as default value for the tail-parameter of a variadic function

        } else {

            if (_type  === ArgueJS.TAIL) { return true; } // any value is compatible as non-default value for the tail-parameter of a variadic function
            if (_value === undefined)    { return (_allowUndefined === true); } // value &quot;undefined&quot; is compatible if &quot;undefined&quot; is allowed
            if (_value === null)         { return (_allowNull === true); } // value &quot;null&quot; is compatible if &quot;null&quot; is allowed
        }
        if (_type  === ArgueJS.ANYTYPE) { return true; } // any value is compatible with ANYTYPE
        return (getType(_value) === _type) || (_value instanceof _type);
    }

    /* ###############################################################################################
     *
     * Class: ArgueJS
     *
     * This class is public and gets exported.
     *
     * ###############################################################################################
     */

    /**
     * Constructor of class ArgueJS. At the moment it does not make any sense to create an object from that class.
     *
     * This class is exported by the module.
     *
     * @for    module-arguejs
     * @class  ArgueJS
     * @constructor
     * @static
     */
    function ArgueJS() {
    }

    /**
     * Constructor of class ANYTYPE. That type is used to mark a parameter as &quot;any type execpt undefined and null allowed&quot;.
     *
     * ANYTYPE is a special type for marking an parameter type as &quot;any type&quot;. That means any type is allowed for that parameter - but of course, &quot;undefined&quot; and &quot;null&quot; are not allowed.
     * If you want to specify an parameter that accepts values of any type and &quot;undefined&quot; and &quot;null&quot; you can do that. In such a case speficy &quot;allowUndefind: true&quot; and &quot;allowNull: true&quot;
     * in the specification of the parameter.
     *
     * @example
     * var arguejs = require(&#x27;arguejs&#x27;);
     *
     * function example() {
     *     var specification = [{canBeAnyTypeOrUndefinedOrNull: {type: arguejs.ANYTYPE, allowUndefined: true, allowNull: true}}];
     *     var _args = arguejs.getArguments(specification, arguments);
     *     return _args.canBeAnyTypeOrUndefinedOrNull;
     * }
     *
     * example(17);
     * example(&quot;Hello world!&quot;);
     * example(true);
     * example(/^[a-z]*$/i);
     * example(new MyClass());
     * 
     * @for    ArgueJS
     * @class  ANYTYPE
     * @constructor
     * @static
     * @final
     */
    ArgueJS.ANYTYPE = function() {};

    /**
     * Constructor of class TAIL. That type is used to mark a parameter as &quot;containing all remaining arguments of a variadic function&quot;.
     *
     * TAIL is a special type for marking an parameter as &quot;array of remaining arguments&quot;. TAIL is used to specify an parameter containing all remaining arguments in a variadic function.
     *
     * @example
     * var arguejs = require(&#x27;arguejs&#x27;);
     *
     * function example() {
     *     var specification = [{obligatoryValue: Number}, {myTail: arguejs.TAIL}];
     *     var _args = arguejs.getArguments(specification, arguments);
     *     console.log(&quot;number=&quot; + _args.Number);
     *     console.log(&quot;tail is &quot; + (_args.myTail === undefined ? &quot;undefined&quot; : &quot;defined and contains &quot; + _args.myTail));
     * }
     *
     * example(17); // myTail is undefined
     * example(1, &quot;Hallo world!&quot;); // myTail = [&quot;Hello world!&quot;]
     * example(39, 3, 1, 5, new MyClass(), false, true, [27,9,3,1]); // myTail = [3, 1, 5, new MyClass(), false, true, [27,9,3,1]]
     *
     * @for    ArgueJS
     * @class  TAIL
     * @constructor
     * @static
     * @final
     */
    ArgueJS.TAIL = function() {};

    /**
     * Gets all arguments based on a programmatic function specification an a list of argument values.
     *
     * @for     ArgueJS
     * @method  getArguments
     * @static
     *
     * @param {Array}            [_functionSpecification]  Optional: Programmatic function specification.
     * @param {Array|Arguments}  _arguments                Concrete Argument values of a function call.
     *
     * @return {Object}  Returns a new object containing all arguments.
     */
    ArgueJS.getArguments = function(_functionSpecification, _arguments) {
        // checks and maps input parameters because this function is part of the public interface
        if (arguments.length === 1) {
            _arguments = arguments[0];
            if (!_arguments || _arguments.length &gt; 0) { throw new Error(formatText($ERR_ARGUEJS_GetParameters_TooManyArguments, &quot;no parameters defined but arguments given&quot;)); }
            return {}; // EARLY EXIT: no function specification given (means: no arguments allowed) and no arguments given -&gt; _arguments validated!
        }
        if (arguments.length != 2) { throw new Error(arguments.length &lt; 1 ? $ERR_BADCALL_NoArguments : $ERR_BADCALL_TooManyArguments); }
        if (!isArray(_functionSpecification)) { throw new Error(formatText($ERR_BADCALL_InvalidTypeOfArgument, &quot;_functionSpecification&quot;)); }
        if (!isArguments(_arguments) &amp;&amp; !isArray(_arguments)) { throw new Error(formatText($ERR_BADCALL_InvalidTypeOfArgument, &quot;_arguments&quot;)); }

        // safe some parameter
        var parameterNum = _functionSpecification.length;

        // the resulting list with arguments
        var resultingArguments = {};

        // process all parameters
        var argumentNum   = _arguments.length;
        var argumentIdx   = 0;
        var argumentValue = _arguments[argumentIdx];
        for (var parameterIdx = 0; parameterIdx &lt; parameterNum; ++parameterIdx) {

            // get current parameter info
            var parameterSpecification = _functionSpecification[parameterIdx];
            if (typeof(parameterSpecification) !== &quot;object&quot;) { throw new Error(formatText($ERR_BADCALL_InvalidTypeOfParameter, parameterIdx)); }

            // get parameter specification
            // &gt;&gt;&gt; irgnore jslint warnings. it is important that these variables get &quot;initialized&quot;. - reason: to reset these variables when looping through parameter specifications
            var parameterName             = undefined;  // the name of the parameter. that is the name of the property in the resulting list of argument values
            var parameterType             = undefined;  // the type of the parameter
            var parameterIsOptional       = undefined;  // undefined|false means &quot;non-optional parameter&quot;; true means &quot;optional parameter&quot;
            var parameterHasDefaultValue  = undefined;  // undefined|false means &quot;has no default value&quot;; true means &quot;has default value&quot;
            var parameterDefaultValue     = undefined;  // if parameterHasDefaultValue is true then the value of that variable is the default value - whatever that value is (undefined, null, a string, a function, an object, ...)
            var parameterAllowUndefined   = undefined;  // undefined means &quot;default behavior or option forbidden (because parameter is tail-parameter)&quot;; false means &quot;explicitly not allowed&quot;; true means &quot;explicit allowed&quot;
            var parameterAllowNull        = undefined;  // undefined means &quot;default behavior or option forbidden (because parameter is tail-parameter)&quot;; false means &quot;explicitly not allowed&quot;; true means &quot;explicit allowed&quot;
            var parameterParenthesizeTail = undefined;  // undefined means &quot;default behavior or option forbidden (because parameter is no tail-parameter)&quot;; false means &quot;explicitly do no parenthesize&quot;; true means &quot;explicitly do no parenthesize&quot;
            // &lt;&lt;&lt; irgnore jslint warnings. it is important that these variables get &quot;initialized&quot;. - reason: to reset these variables when looping through parameter specifications
            for(var parameterId in parameterSpecification) {
                if (parameterSpecification.hasOwnProperty(parameterId)) {

                    // check that not more than one element is in the object because the object (to be exact: the first element in the object) defines the parameter completely
                    if (parameterName) { throw new Error(formatText($ERR_ARGUEJS_ParameterWithTooManyElements, parameterName)); }

                    // get parameter name
                    parameterName = parameterId;
                    if (!validateParameterName(parameterName)) { throw new Error(formatText($ERR_ARGUEJS_InvalidValue, parameterName, &quot;name&quot;)); }

                    // get data of type specification
                    var parameterTypeData = parameterSpecification[parameterId];

                    // get parameter type specification from simple mandatory parameter specification (examples: {message: String})
                    if (isFunction(parameterTypeData)) {

                        parameterIsOptional = false;
                        parameterType       = parameterTypeData;
                    }

                    // get parameter type specification from simple optional parameter specification (examples: {message: [String]}, {myValue: [Number, 17]})
                    else if (isArray(parameterTypeData)) {

                        if (parameterTypeData.length &lt; 1) { throw new Error(formatText($ERR_ARGUEJS_MissingTypeSpecification, parameterName)); }
                        parameterIsOptional = true;
                        parameterType       = parameterTypeData[0];

                        if (parameterTypeData.length &gt;= 2) {
                            if (parameterTypeData.length &gt; 2) { throw new Error(formatText($ERR_ARGUEJS_TypeSpecificationHasTooManyElements, parameterName)); }
                            parameterHasDefaultValue = true;
                            parameterDefaultValue    = parameterTypeData[1];
                        }
                    }

                    // get parameter type specification from complex parameter specification (examples: { message: {type: [String], defaultValue: &quot;Hallo Welt!&quot;, allowUndefined: false, allowNull: false}})
                    else if (isObject(parameterTypeData)) { // @TODO: This test should be improved because of types Array, Date, RegExp, Function - these are definitve not the kind of objects we want

                        for (var key in parameterTypeData) {
                            if (parameterTypeData.hasOwnProperty(key)) {
                                switch(key) {
                                    case(&quot;type&quot;):
                                        parameterIsOptional = isArray(parameterTypeData.type);
                                        parameterType       = (parameterIsOptional ? parameterTypeData.type[0] : parameterTypeData.type);
                                        break;
                                    case(&quot;defaultValue&quot;):
                                        parameterHasDefaultValue = true;
                                        parameterIsOptional      = true; // by specifying a default value a parameter is optional; otherwise it would not make any sense to specify a default value
                                        parameterDefaultValue    = parameterTypeData[key];
                                        break;
                                    case(&quot;allowUndefined&quot;):
                                        parameterAllowUndefined  = parameterTypeData[key];
                                        if (!isBoolean(parameterAllowUndefined)) { throw new Error(formatText($ERR_ARGUEJS_InvalidTypeOfValue, parameterName, &quot;allowUndefined&quot;, &quot;boolean&quot;)); }
                                        break;
                                    case(&quot;allowNull&quot;):
                                        parameterAllowNull = parameterTypeData[key];
                                        if (!isBoolean(parameterAllowNull)) { throw new Error(formatText($ERR_ARGUEJS_InvalidTypeOfValue, parameterName, &quot;allowNull&quot;, &quot;boolean&quot;)); }
                                        break;
                                    case(&quot;parenthesizeTail&quot;):
                                        parameterParenthesizeTail = parameterTypeData[key];
                                        if (!isBoolean(parameterParenthesizeTail)) { throw new Error(formatText($ERR_ARGUEJS_InvalidTypeOfValue, parameterName, &quot;parenthesizeTail&quot;, &quot;boolean&quot;)); }
                                        break;
                                    default:
                                        throw new Error(formatText($ERR_ARGUEJS_InvalidOption, parameterName, key));
                                }
                            }
                        }
                    }
                    else {

                        // it is a type or a value; however we do not accept the parameter type specification (examples: 17, &quot;hello&quot;, false, undefined, null)
                        throw new Error(formatText($ERR_ARGUEJS_InvalidValue, parameterName, &quot;type&quot;));
                    }
                }
            }

            // validate parameter name
            if (!parameterName) { throw new Error(formatText($ERR_ARGUEJS_InvalidTypeSpecificationOption, parameterIdx)); }

            // validate type
            if (!isType(parameterType)) { throw new Error(formatText($ERR_ARGUEJS_InvalidValue, parameterName, &quot;type&quot;)); }

            // validate: special checks for variadic or non-variadic functions
            if (parameterType !== ArgueJS.TAIL) {

                // &quot;parenthesizeTail&quot; can only be used for the tail-parameter in a variadic function
                if (parameterParenthesizeTail !== undefined) { throw new Error(formatText($ERR_ARGUEJS_ParameterXYZAllowedInVariadicFunction, parameterName, &quot;parenthesizeTail&quot;, &quot;only&quot;)); }

                // set default values for allowUndefined and allowNull, if options are undefined
                if (parameterAllowUndefined === undefined) { parameterAllowUndefined = DEFAULT_OPTION_VALUE_ALLOWUNDEFINED; }
                if (parameterAllowNull      === undefined) { parameterAllowNull      = DEFAULT_OPTION_VALUE_ALLOWNULL; }
            }
            else {

                // &quot;allowUndefined&quot; cannot be used for the tail-parameter in a variadic function
                if (parameterAllowUndefined !== undefined) { throw new Error(formatText($ERR_ARGUEJS_ParameterXYZAllowedInVariadicFunction, parameterName, &quot;allowUndefined&quot;, &quot;not&quot;)); }

                // &quot;allowNull&quot; cannot be used for the tail-parameter in a variadic function
                if (parameterAllowNull !== undefined) { throw new Error(formatText($ERR_ARGUEJS_ParameterXYZAllowedInVariadicFunction, parameterName, &quot;allowNull&quot;, &quot;not&quot;)); }

                // we found the tail-parameter of a variadic function. that parameter must be the last parameter in the function specification, because that parameter consumes all remaining values
                if (parameterIdx != (parameterNum-1)) { throw new Error($ERR_ARGUEJS_TailParameterMustBeLastPastparameter); }

                // set default value for parenthesizeTail, if option is undefined
                if (parameterParenthesizeTail === undefined) { parameterParenthesizeTail = DEFAULT_OPTION_VALUE_PARAMETERPARENTHESIZETAIL; }
            }

            // are there remaining arguments?
            if (argumentIdx &lt; argumentNum) {

                // yes, there is at least one argument that was not consumed.
                // ATTENTION! if there is at least one argument that is unprocessed (and that is the case here) then the value of the current argument to process is already stored in argumentValue!

                // is the current argument value compatible to the current parameter specification?
                if (isCompatibleValue(argumentValue, parameterType, parameterAllowUndefined, parameterAllowNull, false)) {

                    if (parameterType === ArgueJS.TAIL) {

                        // is the current argument not the last one? are there more remaining arguments?
                        if (++argumentIdx &lt; argumentNum) {

                            // add a copy of remaining argument values (including the current argument value) to the list of resulting argument values
                            var tail = [argumentValue];
                            do {
                                tail[tail.length] = _arguments[argumentIdx];
                            } while(++argumentIdx &lt; argumentNum);
                            resultingArguments[parameterName] = tail;
                        }
                        else  if (!isArray(argumentValue) || parameterParenthesizeTail) {

                            // build a new array for the tail-argument and add that array to the list of resulting argument values
                            resultingArguments[parameterName] = [argumentValue];
                        }
                        else {

                            // the current argument value is the last argument value and it is an array. but we should not parenthesize (nesting) that array in a new array. so the current array argument is the value (array) for the tail-argument.
                            resultingArguments[parameterName] = argumentValue;
                        }

                        // finish the loop
                        // here we could also do an &quot;return resultingArguments&quot; but I am a friend of &quot;one function one exit point&quot; - except for early exits, exceptions and simple switch-case-like mapping functions
                        argumentIdx = argumentNum;
                        break;
                    }
                    else {

                        // store the argument value in the resulting argument list
                        resultingArguments[parameterName] = argumentValue;

                        // advance to the next argument value if it exists
                        ++argumentIdx;
                        if (argumentIdx &lt; argumentNum) {
                            argumentValue = _arguments[argumentIdx];
                        }
                    }

                    // because the current parameter specification is processed we advance to the next parameter specification
                    continue;
                }
            }

            // no, all arguments are already processed. no arguments are remaing otherwise we would never reach this line of code

            // if the current parameter is not optional then there were too less arguments given in the function call
            if (!parameterIsOptional) { throw new Error(formatText($ERR_ARGUEJS_GetParameters_MandatoryParameterWithoutValue, parameterName)); }

            // the parameter is optional. does the parameter specification define a default value?
            if (parameterHasDefaultValue) {

                // that is the value we will add later to the list of resulting arguments
                var defaultValue;

                // get the default value
                if (!isFunction(parameterDefaultValue) || isFunction(parameterType)) {

                    // the default value of the parameter is no function OR the default value is a function and the type of the parameter is &quot;Function&quot; too
                    // in both cases we can directy try to use that value directly
                    defaultValue = parameterDefaultValue;
                }
                else {

                    // the default value of the parameter is a function but the type of the parameter is not &quot;Function&quot;
                    // then we the function specified in the default value to get the true default value for that parameter
                    defaultValue = parameterDefaultValue();
                }

                // now we have a default value - whatever that default values is. but that default value has to be compatible &quot;as a default value&quot; with the type of the parameter
                if (!isCompatibleValue(defaultValue, parameterType, parameterAllowUndefined, parameterAllowNull, true)) { throw new Error(formatText($ERR_ARGUEJS_DefaultValueHasIncompatibleType, parameterName)); }

                // store the default value into the list of resulting arguments
                resultingArguments[parameterName] = defaultValue;
            }
        }

        // all parameter specifications were processed. are there still remaining arguments?
        if (argumentIdx &lt; argumentNum) { throw new Error(formatText($ERR_ARGUEJS_GetParameters_TooManyArguments, &quot;there are arguments left but all parameters are processed.&quot;)); }

        // FINISHED!
        return resultingArguments;
    };

    /* ###############################################################################################
     *
     *  FINISH MODULE EXPORT DEFINITION
     *
     * ###############################################################################################
     */

    /**
     * @exports {ArgueJS}  Export the class.
     */
    return ArgueJS;

// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
// [[&gt;&gt;&gt; make module available in node.js and the web (AMD - RequireJS)]]
// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    });
});
// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
// [[&lt;&lt;&lt; make module available in node.js and the web (AMD - RequireJS)]]
// &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
